---
title: Redis问题笔记
date: 2021-03-17 22:55:40
tags:
    - Redis
categories:
    - DevOps
copyright: false
toc: true
---



## Redis为什么快

原因主要是以下三点：
- 纯内存操作
- 单线程操作，避免了频繁的上下文切换
- 采用了非阻塞 I/O 多路复用机制

<!-- more -->



> 在项目中使用 Redis，主要考虑两个角度：性能和并发。如果只是为了分布式锁这些其他功能，还有其他中间件 Zookpeer 等代替，并非一定要使用 Redis。



## Redis的数据类型

**String**

**Hash**

**List**

使用 List 的数据结构，可以做简单的消息队列的功能。另外，可以利用 lrange 命令，做基于 Redis 的分页功能，性能极佳，用户体验好。

**Set**

**Sorted Set**



## Redis常见问题

- 缓存和数据库双写一致性问题
- 缓存雪崩问题
- 缓存击穿问题
- 缓存的并发竞争问题



## Redis 的过期策略和内存淘汰机制

Redis 采用的是定期删除+惰性删除的过期策略。

定期删除，Redis 默认每100ms 检查一次，有过期 Key 则删除。但不是每100ms 将所有的 Key 检查一次，而是随机抽取进行检查。如果只采用定期删除策略，会导致很多 Key 到时间没有删除。于是，惰性删除派上用场。

如果定期删除没删除掉 Key。并且你也没及时去请求 Key，也就是说惰性删除也没生效。这样，Redis 的内存会越来越高。那么就应该采用**内存淘汰机制**。

- noeviction：当内存不足以容纳新写入数据时，新写入操作会报错。
- allkeys-lru：***当内存不足以容纳新写入数据时，在键空间中，移除最近最少使用的 Key***。（推荐使用，目前项目在用这种）(最近最久使用算法)
- allkeys-random：当内存不足以容纳新写入数据时，在键空间中，随机移除某个 Key。（应该也没人用吧，你不删最少使用 Key，去随机删）
- volatile-lru：当内存不足以容纳新写入数据时，在设置了过期时间的键空间中，移除最近最少使用的 Key。这种情况一般是把 Redis 既当缓存，又做持久化存储的时候才用。（不推荐）
- volatile-random：当内存不足以容纳新写入数据时，在设置了过期时间的键空间中，随机移除某个 Key。（依然不推荐）
- volatile-ttl：当内存不足以容纳新写入数据时，在设置了过期时间的键空间中，有更早过期时间的 Key 优先移除。（不推荐）

默认配置的是： maxmemory-policy volatile-lru
推荐： maxmemory-policy ***allkeys-lru



## Redis 和数据库双写一致性问题

一致性问题还可以再分为最终一致性和强一致性。数据库和缓存双写，就必然会存在不一致的问题。如果对数据有强一致性要求，不能放缓存。我们所做的一切，只能保证最终一致性。

首先，采取正确更新策略，先更新数据库，再删缓存。
其次，因为可能存在删除缓存失败的问题，提供一个补偿措施即可，例如利用消息队列。



## 缓存穿透和缓存雪崩问题

缓存穿透解决方案：
- 利用互斥锁，缓存失效的时候，先去获得锁，得到锁了，再去请求数据库。没得到锁，则休眠一段时间重试。
- 采用异步更新策略，无论 Key 是否取到值，都直接返回。Value 值中维护一个缓存失效时间，缓存如果过期，异步起一个线程去读数据库，更新缓存。需要做缓存预热(项目启动前，先加载缓存)操作。
- 提供一个能迅速判断请求是否有效的拦截机制，比如，利用布隆过滤器，内部维护一系列合法有效的 Key。迅速判断出，请求所携带的 Key 是否合法有效。如果不合法，则直接返回。


缓存雪崩，即缓存同一时间大面积的失效，这个时候又来了一波请求，结果请求都怼到数据库上，从而导致数据库连接异常。



缓存雪崩解决方案：
- 给缓存的失效时间，加上一个随机值，避免集体失效。
- 使用互斥锁，但是该方案吞吐量明显下降了。
- 双缓存。我们有两个缓存，缓存 A 和缓存 B。缓存 A 的失效时间为 20 分钟，缓存 B 不设失效时间。自己做缓存预热操作。
- 然后细分以下几个小点：从缓存 A 读数据库，有则直接返回；A 没有数据，直接从 B 读数据，直接返回，并且异步启动一个更新线程，更新线程同时更新缓存 A 和缓存 B。


*来源：www.cnblogs.com/yaodengyan/p/9717080.html*



---



## 并发竞争Key问题

并发竞争key，即同时有多个客户端去set一个key。解决方法：

**乐观锁**
对修改顺序没有要求的场景，并且redis没有使用分片时，可以通过**watch**命令实现。watch命令会监视给定的每一个key，当exec时如果监视的任一个key自从调用watch后发生过变化，则整个事务会回滚，不执行任何动作。


**分布式锁**
对修改顺序没有要求的场景，准备一个分布式锁，抢到锁才能set。

**时间戳**
对于有顺序要求的场景，在写入时保存一个时间戳，写入前先比较自己的时间戳是不是早于现有记录的时间戳，如果早于，就不写入了。

**队列**
通过消息队列进行串行化处理。



*原文：<https://blog.csdn.net/suifeng629/article/details/103304247>*